# AI项目快速自动孵化器 - 模块1: 输入模块 技术方案文档

## 文档版本信息
- **版本**: 1.0
- **日期**: 2025-08-12
- **作者**: 全栈开发工程师 (基于Grok AI模拟)
- **目的**: 本文档针对“AI项目快速自动孵化器”的输入模块，提供使用Vue.js（前端）和Python（后端，采用Flask框架）的技术实现方案。方案覆盖模块的所有功能点，确保高效、可扩展和用户友好。设计遵循MVC模式，前端处理UI交互，后端处理数据验证和存储。
- **技术栈概述**:
  - **前端**: Vue.js 3 (Composition API)，结合Ant Design Vue (UI组件库) 和 Axios (HTTP请求)。
  - **后端**: Python 3.12 with Flask (Web框架)，结合Flask-Uploads (文件上传)、SQLAlchemy (数据库交互，SQLite作为存储)。
  - **集成**: RESTful API，前后端分离；使用CORS支持跨域。
  - **假设**: 系统运行在本地开发环境，生产时可部署到Heroku/AWS。用户认证使用JWT（后续模块扩展）。

## 模块概述
输入模块负责收集用户项目idea、文件上传和参数配置，确保数据完整性。该模块功能点包括：
1. idea文本输入功能
2. 文件上传支持
3. 参数配置面板
4. 模板选择功能
5. 实时输入验证
6. 多语言支持输入
7. 历史idea列表
8. 协作输入模式 (MVP阶段Won't-have，标记为可选)
9. 隐私同意弹窗
10. 输入预览与确认

方案设计强调响应式UI、实时反馈和安全性（如输入 sanitization）。开发周期估算：前端3人天，后端2人天，集成测试1人天。

## 前端实现方案 (Vue.js)
前端使用Vue.js构建单页应用（SPA），入口文件`main.js`初始化Vue App。组件化设计：主组件`InputModule.vue`整合子组件。使用Pinia作为状态管理，存储临时输入数据。

### 1. 项目结构
```
src/
├── components/
│   ├── InputTextArea.vue     // idea文本输入
│   ├── FileUploader.vue      // 文件上传
│   ├── ParamConfigPanel.vue  // 参数配置
│   ├── TemplateSelector.vue  // 模板选择
│   ├── ValidationPanel.vue   // 实时验证
│   ├── LanguageSwitcher.vue  // 多语言支持
│   ├── HistoryList.vue       // 历史idea列表
│   ├── PrivacyModal.vue      // 隐私同意弹窗
│   └── PreviewConfirm.vue    // 输入预览与确认
├── stores/
│   └── inputStore.js         // Pinia store
├── App.vue
└── main.js
```

### 2. 核心组件实现详情

#### idea文本输入功能 (InputTextArea.vue)
- **描述**: 多行文本框，支持实时字数统计、自动保存草稿（localStorage）。
- **实现**:
  - 使用Ant Design Vue的`<a-textarea>`组件。
  - 事件绑定：`@input`实时更新Pinia store，并计算字数（上限5000）。
  - 自动保存：使用`watch`监听变化，每5s保存到localStorage。
  - 示例代码:
    ```vue
    <template>
      <a-textarea v-model:value="idea" :rows="10" placeholder="请输入项目idea" :maxlength="5000" />
      <div>字数: {{ wordCount }} / 5000</div>
    </template>
    <script setup>
    import { ref, computed, watch } from 'vue';
    import { useInputStore } from '@/stores/inputStore';
    const store = useInputStore();
    const idea = ref(store.idea);
    const wordCount = computed(() => idea.value.length);
    watch(idea, (newVal) => {
      store.setIdea(newVal);
      localStorage.setItem('draftIdea', newVal);
    }, { deep: true });
    // 初始化从localStorage加载
    onMounted(() => {
      idea.value = localStorage.getItem('draftIdea') || '';
    });
    </script>
    ```

#### 文件上传支持 (FileUploader.vue)
- **描述**: 支持拖拽/PDF/DOCX/TXT上传，多文件（上限5，总<10MB），自动解析并合并到idea。
- **实现**:
  - 使用Ant Design Vue的`<a-upload-dragger>`组件。
  - 上传前校验文件类型/大小；上传到后端API `/upload`，成功后解析内容追加到idea。
  - 进度条使用组件内置。
  - 示例代码:
    ```vue
    <template>
      <a-upload-dragger v-model:fileList="fileList" :multiple="true" :action="uploadUrl" :before-upload="beforeUpload">
        <p>拖拽或点击上传文件 (PDF/DOCX/TXT)</p>
      </a-upload-dragger>
      <div v-if="uploadedFiles.length">已上传: {{ uploadedFiles.join(', ') }}</div>
    </template>
    <script setup>
    import { ref } from 'vue';
    import axios from 'axios';
    const fileList = ref([]);
    const uploadUrl = '/api/upload';
    const uploadedFiles = ref([]);
    const beforeUpload = (file) => {
      if (!['pdf', 'docx', 'txt'].includes(file.type.split('/')[1])) {
        alert('不支持的文件类型');
        return false;
      }
      if (file.size > 10 * 1024 * 1024) {
        alert('文件过大');
        return false;
      }
      return true;
    };
    // 上传成功回调：后端返回解析文本，追加到store
    const handleUpload = async (info) => {
      if (info.file.status === 'done') {
        const response = await axios.post('/api/parse-file', { file: info.file.name });
        store.appendToIdea(response.data.text);
        uploadedFiles.value.push(info.file.name);
      }
    };
    </script>
    ```

#### 参数配置面板 (ParamConfigPanel.vue)
- **描述**: 折叠面板，下拉/滑块选择AI模型、语言、详细度。
- **实现**:
  - 使用`<a-collapse>`和`<a-select>`、`<a-slider>`。
  - 实时更新store，并预估时间（简单计算）。
  - 示例代码:
    ```vue
    <template>
      <a-collapse>
        <a-collapse-panel header="参数配置">
          <a-select v-model:value="model" :options="modelOptions" />
          <a-select v-model:value="language" :options="langOptions" />
          <a-slider v-model:value="detailLevel" :marks="detailMarks" />
          <div>预计时间: {{ estimatedTime }} min</div>
        </a-collapse-panel>
      </a-collapse>
    </template>
    <script setup>
    import { ref, computed } from 'vue';
    const model = ref('Grok');
    const language = ref('中文');
    const detailLevel = ref(2);
    const estimatedTime = computed(() => detailLevel.value * 1.5);
    // 绑定到store
    </script>
    ```

#### 其他功能点实现简述
- **模板选择 (TemplateSelector.vue)**: `<a-select>`加载后端模板列表，一键填充idea。
- **实时输入验证 (ValidationPanel.vue)**: Side panel with icons；使用JS regex校验关键元素，AI辅助调用小型API。
- **多语言支持 (LanguageSwitcher.vue)**: `<a-button>`切换，集成i18n插件。
- **历史idea列表 (HistoryList.vue)**: `<a-list>`从后端API `/history`获取，登录用户可见。
- **隐私同意弹窗 (PrivacyModal.vue)**: `<a-modal>` on mount 显示，同意后启用提交。
- **输入预览与确认 (PreviewConfirm.vue)**: `<a-modal>`显示合并idea，确认提交到后端触发prompt链。
- **协作输入模式**: 使用Socket.io集成实时编辑（可选，MVP后实现）。

### 3. 状态管理 (inputStore.js)
使用Pinia：
```javascript
import { defineStore } from 'pinia';
export const useInputStore = defineStore('input', {
  state: () => ({
    idea: '',
    params: { model: 'Grok', language: 'en', detail: 2 },
    files: [],
  }),
  actions: {
    setIdea(val) { this.idea = val; },
    appendToIdea(text) { this.idea += text; },
  },
});
```

### 4. API交互
使用Axios发送POST到后端`/submit-idea`，携带JSON payload。

## 后端实现方案 (Python with Flask)
后端使用Flask构建REST API，处理上传、解析、存储。数据库SQLite存储历史idea。

### 1. 项目结构
```
app/
├── api/
│   ├── __init__.py
│   ├── routes.py     // API endpoints
│   └── models.py     // SQLAlchemy models
├── utils/
│   └── file_parser.py  // 文件解析逻辑
├── app.py
└── requirements.txt  // Flask, Flask-Uploads, PyPDF2, docx, SQLAlchemy
```

### 2. 核心API实现 (routes.py)
```python
from flask import Blueprint, request, jsonify
from flask_uploads import UploadSet, configure_uploads, DOCUMENTS
from app.models import db, IdeaHistory
from utils.file_parser import parse_file
import os

api = Blueprint('api', __name__)
uploads = UploadSet('files', DOCUMENTS)

@api.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({'error': 'No file'}), 400
    file = request.files['file']
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        file.save(os.path.join(app.config['UPLOADED_FILES_DEST'], filename))
        return jsonify({'message': '上传成功', 'filename': filename}), 200
    return jsonify({'error': 'Invalid file'}), 400

@api.route('/parse-file', methods=['POST'])
def parse_file_api():
    filename = request.json.get('file')
    text = parse_file(filename)
    return jsonify({'text': text}), 200

@api.route('/submit-idea', methods=['POST'])
def submit_idea():
    data = request.json
    idea = data['idea']
    params = data['params']
    # 存储到数据库
    new_idea = IdeaHistory(idea=idea, params=str(params), user_id=1)  # 假设用户ID
    db.session.add(new_idea)
    db.session.commit()
    # 触发prompt链（后续模块）
    return jsonify({'message': '提交成功', 'id': new_idea.id}), 200

@api.route('/history', methods=['GET'])
def get_history():
    ideas = IdeaHistory.query.filter_by(user_id=1).all()
    return jsonify([{'id': i.id, 'idea': i.idea} for i in ideas]), 200

@api.route('/templates', methods=['GET'])
def get_templates():
    # 硬编码或从DB加载
    templates = [{'name': 'Web App', 'content': '构建一个Web应用...'}]
    return jsonify(templates), 200

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in {'pdf', 'docx', 'txt'}
```

### 3. 文件解析工具 (file_parser.py)
```python
import PyPDF2
import docx
def parse_file(filename):
    ext = filename.split('.')[-1]
    if ext == 'pdf':
        with open(filename, 'rb') as f:
            reader = PyPDF2.PdfReader(f)
            text = ''.join(page.extract_text() for page in reader.pages)
    elif ext == 'docx':
        doc = docx.Document(filename)
        text = '\n'.join(para.text for para in doc.paragraphs)
    elif ext == 'txt':
        with open(filename, 'r') as f:
            text = f.read()
    else:
        text = ''
    return text
```

### 4. 数据库模型 (models.py)
```python
from flask_sqlalchemy import SQLAlchemy
db = SQLAlchemy()

class IdeaHistory(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    idea = db.Column(db.Text, nullable=False)
    params = db.Column(db.String(500))
    user_id = db.Column(db.Integer)
```

### 5. App初始化 (app.py)
```python
from flask import Flask
from flask_cors import CORS
from api.routes import api
from api.models import db
from flask_uploads import configure_uploads

app = Flask(__name__)
CORS(app)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///ideas.db'
app.config['UPLOADED_FILES_DEST'] = 'uploads/'
db.init_app(app)
configure_uploads(app, uploads)
app.register_blueprint(api, url_prefix='/api')

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)
```

### 6. 其他后端细节
- **实时验证**: 前端主，后端API `/validate-idea` 使用简单NLP（可选集成spacy）检查关键元素。
- **多语言**: 后端返回i18n字符串。
- **安全**: 使用`werkzeug.security` sanitization 文件名；限流上传。
- **历史列表**: 需要用户认证（JWT扩展）。

## 前后端集成与测试
- **API调用**: 前端Axios baseURL='/api'，错误处理统一modal。
- **部署**: 前端build到static，后端serve；Docker-compose集成。
- **测试**:
  - 单元测试: Vue使用Jest测试组件；Python使用pytest测试API。
  - 集成测试: Cypress端到端模拟输入流程。
- **性能优化**: Debounce输入事件；懒加载组件。
- **边界处理**: 空输入/超限提示；网络错误重试。

此方案确保输入模块高效落地，如需代码仓库或进一步迭代，请提供反馈。