# model: gpt-oss:latest
# prompt: <system>你是一名 AI 编程助手。请根据以下需求完成代码变更，并将所有需要执行的 Git 操作以“代码输出协议（COP）”格式返回。  
1. 使用 BEGIN COP … END COP 包裹指令块。  
2. 每条操作以 ACTION: 开头，后面跟随动作名：CREATE_FILE, UPDATE_FILE, DELETE_FILE, COMMIT, PULL, CREATE_BRANCH, PUSH。  
3. 在 PARAMS: 行后写 JSON（或 YAML）对象，描述参数。 
 4. 对于 CREATE_FILE/UPDATE_FILE，使用 CONTENT: 开始后写文件内容，以 END_CONTENT 结束。 
 5. 所有字段使用英文，严格遵守语法；不要在 COP 外部写任何解释文字。 
 6. 若需要多条操作，按顺序依次写；脚本会一次性执行。</system>
<requirement>用一个html页面实现一个俄罗斯方块小游戏</requirement>
# answer: 
 thinking:

We need to provide code changes to create an HTML page for Tetris. The repository presumably is empty or minimal. We need to create an HTML file, maybe index.html, with Tetris logic. Also maybe CSS. We need to commit. Provide COP with CREATE_FILE for index.html, maybe style in the same file.

We must think about repository structure. We might just create a file at root: tetris.html or index.html. We'll create "tetris.html" with minimal Tetris implementation. Let's write an HTML file with canvas, JavaScript for Tetris logic. Use canvas 200x400? Tetris grid 10x20, cell size 20. Provide key event handlers.

Implement basic Tetris: shapes, rotation, grid, collision detection, line clear, score. For brevity.

We'll create file content. Also maybe a README? Not required.

Thus COP: CREATE_FILE for tetris.html with content. Then COMMIT with message. No other operations needed. Possibly create branch? Not necessary.

Thus output: BEGIN COP ... END COP. Each operation: ACTION: CREATE_FILE, PARAMS: JSON. CONTENT: ... END_CONTENT. Then ACTION: COMMIT, PARAMS: JSON {message: "Add Tetris game"}.

Return only COP block.

thinking end 

BEGIN COP
ACTION: CREATE_FILE
PARAMS:
{
  "path": "tetris.html"
}
CONTENT:
```
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Tetris</title>
<style>
  body { margin: 0; background: #222; color: #fff; font-family: sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; }
  #gameCanvas { background: #111; }
</style>
</head>
<body>
<canvas id="gameCanvas" width="200" height="400"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const COLS = 10;
const ROWS = 20;
const BLOCK_SIZE = 20;
const COLORS = ['cyan', 'blue', 'orange', 'yellow', 'green', 'purple', 'red'];
const SHAPES = [
  // I
  [[1,1,1,1]],
  // J
  [[1,0,0],[1,1,1]],
  // L
  [[0,0,1],[1,1,1]],
  // O
  [[1,1],[1,1]],
  // S
  [[0,1,1],[1,1,0]],
  // T
  [[0,1,0],[1,1,1]],
  // Z
  [[1,1,0],[0,1,1]]
];

class Piece {
  constructor(shape, color) {
    this.shape = shape;
    this.color = color;
    this.rotation = 0;
    this.x = Math.floor(COLS / 2) - Math.ceil(shape[0].length / 2);
    this.y = 0;
  }
  get cells() {
    const rotShape = rotate(this.shape, this.rotation);
    return rotShape;
  }
}

function rotate(matrix, times) {
  let result = matrix;
  for (let i = 0; i < times; i++) {
    const rows = result.length;
    const cols = result[0].length;
    const rotated = Array.from({ length: cols }, () => Array(rows).fill(0));
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        rotated[c][rows - 1 - r] = result[r][c];
      }
    }
    result = rotated;
  }
  return result;
}

class Tetris {
  constructor() {
    this.board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    this.score = 0;
    this.gameOver = false;
    this.current = this.randomPiece();
    this.next = this.randomPiece();
    this.dropCounter = 0;
    this.dropInterval = 1000;
    this.lastTime = 0;
    this.bindKeys();
    this.update();
  }
  randomPiece() {
    const id = Math.floor(Math.random() * SHAPES.length);
    return new Piece(SHAPES[id], COLORS[id]);
  }
  collide(offsetX = 0, offsetY = 0, rotation = 0) {
    const shape = rotate(this.current.shape, this.current.rotation + rotation);
    for (let y = 0; y < shape.length; y++) {
      for (let x = 0; x < shape[y].length; x++) {
        if (shape[y][x]) {
          const newX = this.current.x + x + offsetX;
          const newY = this.current.y + y + offsetY;
          if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
          if (newY >= 0 && this.board[newY][newX]) return true;
        }
      }
    }
    return false;
  }
  merge() {
    const shape = this.current.shape;
    for (let y = 0; y < shape.length; y++) {
      for (let x = 0; x < shape[y].length; x++) {
        if (shape[y][x]) {
          if (this.current.y + y < 0) {
            this.gameOver = true;
            return;
          }
          this.board[this.current.y + y][this.current.x + x] = this.current.color;
        }
      }
    }
  }
  clearLines() {
    let rowsCleared = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--) {
      for (let x = 0; x < COLS; x++) {
        if (!this.board[y][x]) continue outer;
      }
      const removed = this.board.splice(y, 1)[0];
      this.board.unshift(Array(COLS).fill(0));
      rowsCleared++;
      y++; // recheck same row
    }
    if (rowsCleared) {
      this.score += [0, 40, 100, 300, 1200][rowsCleared];
    }
  }
  drop() {
    if (!this.collide(0,1)) {
      this.current.y++;
    } else {
      this.merge();
      this.clearLines();
      this.current = this.next;
      this.next = this.randomPiece();
      if (this.collide()) this.gameOver = true;
    }
    this.dropCounter = 0;
  }
  move(dir) {
    if (!this.collide(dir,0)) {
      this.current.x += dir;
    }
  }
  rotate() {
    if (!this.collide(0,0,1)) {
      this.current.rotation = (this.current.rotation + 1) % 4;
    }
  }
  hardDrop() {
    while (!this.collide(0,1)) {
      this.current.y++;
    }
    this.drop();
  }
  bindKeys() {
    document.addEventListener('keydown', e => {
      if (this.gameOver) return;
      switch(e.key) {
        case 'ArrowLeft':
          this.move(-1); break;
        case 'ArrowRight':
          this.move(1); break;
        case 'ArrowDown':
          this.drop(); break;
        case 'ArrowUp':
          this.rotate(); break;
        case ' ':
          this.hardDrop(); break;
      }
    });
  }
  draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // board
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        if (this.board[y][x]) {
          ctx.fillStyle = this.board[y][x];
          ctx.fillRect(x*BLOCK_SIZE, y*BLOCK_SIZE, BLOCK_SIZE-1, BLOCK_SIZE-1);
        }
      }
    }
    // current piece
    const shape = this.current.shape;
    for (let y = 0; y < shape.length; y++) {
      for (let x = 0; x < shape[y].length; x++) {
        if (shape[y][x]) {
          ctx.fillStyle = this.current.color;
          ctx.fillRect((this.current.x + x)*BLOCK_SIZE, (this.current.y + y)*BLOCK_SIZE, BLOCK_SIZE-1, BLOCK_SIZE-1);
        }
      }
    }
    // score
    ctx.fillStyle = '#fff';
    ctx.font = '16px monospace';
    ctx.fillText('Score: '+this.score, 5, canvas.height - 10);
    if (this.gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = '30px monospace';
      ctx.fillText('Game Over', canvas.width/2-80, canvas.height/2);
    }
  }
  update(time = 0) {
    const deltaTime = time - this.lastTime;
    this.lastTime = time;
    this.dropCounter += deltaTime;
    if (this.dropCounter > this.dropInterval) this.drop();
    this.draw();
    if (!this.gameOver) requestAnimationFrame(this.update.bind(this));
  }
}
new Tetris();
</script>
</body>
</html>
```
END_CONTENT
ACTION: COMMIT
PARAMS:
{
  "message": "Add Tetris game implemented in tetris.html"
}
END COP


